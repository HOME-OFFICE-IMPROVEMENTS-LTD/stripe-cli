package stripe

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/ajg/form"

	"github.com/google/uuid"
	"github.com/spf13/cobra"
)

//
// Public types
//

// CLIAnalyticsEventContext is the structure that holds telemetry data sent to the Stripe Analytics Service
// this could be a problem if we are running multiple commands at once. I think we want to initialize this once and pass it along.
type CLIAnalyticsEventContext struct {
	UserAgent         string `form:"user_agent"`
	InvocationID      string `form:"invocation_id"`
	CommandPath       string `form:"command_path"`
	Merchant          string `form:"merchant"`
	CLIVersion        string `form:"cli_version"`
	OS                string `form:"os"`
	GeneratedResource bool   `form:"generated_resource"`
	RequestID         string `form:"request_id"`
	LiveMode          bool   `form:"live_mode"`
}

//
// Public functions
//

// GetAnalyticsEventContextInstance returns the CLIAnalyticsEventContext instance (initializing it  first if necessary).
func GetAnalyticsEventContextInstance() *CLIAnalyticsEventContext {
	telemetrySync.Do(func() {
		telemetryInstance = &CLIAnalyticsEventContext{}
	})

	return telemetryInstance
}

//
// Private types
//
type CLIAnalyticsEvent struct {
	CLIAnalyticsEventContext
	ClientID   string    `form:"client_id"`
	EventID    string    `form:"event_id"`
	EventName  string    `form:"event_name"`
	EventValue string    `form:"event_value"`
	Created    time.Time `form:"created"`
}

//
// Private variables
//

var telemetryInstance *CLIAnalyticsEventContext
var telemetrySync sync.Once

// Private functions

// SetCommandContext sets the telemetry values for the command being executed.
// Needs to come from the gRPC method name.
// How does this work for the gRPC stuff, how does it work now? do we get anything at all?
func (e *CLIAnalyticsEventContext) SetCommandContext(cmd *cobra.Command) {
	e.CommandPath = cmd.CommandPath()
	e.GeneratedResource = false

	for _, value := range cmd.Annotations {
		// Generated commands have an annotation called "operation", we can
		// search for that to let us know it's generated
		if value == "operation" {
			e.GeneratedResource = true
		}
	}
}

// SetInvocationId sets the invocationId in context with an autogenerated UUID
func (e *CLIAnalyticsEventContext) SetInvocationId() {
	e.InvocationID = uuid.NewString()
}

// SendEvent sends a telemetry event to r.stripe.com
func SendEvent(ctx context.Context, eventName string, eventValue string) (*http.Response, error) {
	client := newTelemetryHTTPClient(false)

	if telemetryOptedOut(os.Getenv("STRIPE_CLI_TELEMETRY_OPTOUT")) {
		return nil, nil
	}

	analyticsURL, err := url.Parse("https://r.stripe.com/0")
	if err != nil {
		return nil, err
	}

	data, _ := form.EncodeToValues(GetAnalyticsEventContextInstance())
	data.Set("client_id", "stripe-cli")
	data.Set("event_id", uuid.NewString())
	data.Set("event_name", eventName)
	data.Set("event_value", eventValue)
	data.Set("created", fmt.Sprint((time.Now().Unix())))

	req, err := http.NewRequest(http.MethodPost, analyticsURL.String(), strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}

	req.Header.Set("origin", "stripe-cli")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	if ctx != nil {
		req = req.WithContext(ctx)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

func newTelemetryHTTPClient(verbose bool) *http.Client {
	httpTransport := &http.Transport{
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		TLSHandshakeTimeout: 10 * time.Second,
	}

	tr := &verboseTransport{
		Transport: httpTransport,
		Verbose:   verbose,
		Out:       os.Stderr,
	}

	return &http.Client{
		Transport: tr,
	}
}
